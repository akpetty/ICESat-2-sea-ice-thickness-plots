import matplotlib, sys
matplotlib.use('Agg')
from mpl_toolkits.basemap import Basemap
import numpy as np
from pylab import *
import numpy.ma as ma
import xarray as xr
import pandas as pd
import os
from glob import glob
import netCDF4 as nc4
from scipy.interpolate import griddata
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import matplotlib.colorbar as mcbar

import time
import sys
sys.path.append('../')
import common_functions as cF
from matplotlib.gridspec import GridSpec
from mpl_toolkits.axes_grid1 import make_axes_locatable
from astropy.convolution import convolve
from astropy.convolution import Gaussian2DKernel
import cmocean
cF.reset_matplotlib()


def getIS2Data(dataPath, dates): 
    """Gets ICESat-2 data for provided date range
    
    Args: 
        dataPath (str): path to local directory of ICESat-2 data 
        dates (list): pandas Timestamp objects generated by getWinterDateRange
        
    Returns: 
        is2 (xarray dataset): ICESat-2 data or NONE if file does not exist for inputted date range
    """
    is2List = [] #empty list for compiling xarray DataArray objects
    for date in dates: 
        try:
            filename = glob(dataPath+ 'IS2*' + date.strftime('%y') + date.strftime('%m') + '*.nc')[0]
        except: 
            print('Cannot find files; check date range, filepath or if glob is imported')
            return None
        is2 = xr.open_dataset(filename)
        is2 = is2.assign_coords({'time': date})
        is2List.append(is2)
    is2Data = xr.concat(is2List, dim = 'time') #concatenate all DataArray objects into a single DataArray
    
    return is2Data

def getWinterDateRange(start_year, end_year): 
    """ Gets date range for winter season/s
    Args: 
        start_year (int): start year 
        end_year (int): end year 
        
    Returns: 
        winters (list): list of dates for all winter seasons in the input range (i.e: ['1980-11','1980-12','1981-01',
         '1981-02','1981-03','1981-04')
    """
    winters = []
    for year in range(start_year, end_year+1, 1):

        winters += pd.date_range(start = str(year) + '-11', end = str(year + 1) + '-04', freq = 'MS')
    return winters

def getRegionMask(dataPath): 
    """Gets NSIDC region mask for map projection
    
     Args:
         dataPath (str): path to NSIDC region mask
         
     Returns: 
         shapedMask (numpy array): NSIDC arctic region mask gridded to shape [448, 304]
         shapedLons (numpy array): longitudes gridded to shape [448, 304]
         shapedLats (numpy array): latitudes gridded to shape [448, 304] 
    """ 
    gridShape = [448, 304] #shape of grid to reshape data to 
    
    regionMask = open(dataPath + '/sect_fixed_n.msk', 'rb') #open region mask 
    shapedMask = np.reshape(np.fromfile(file = regionMask, dtype='uint8'), gridShape) #reshape mask to grid shape
    
    maskLons = open(dataPath + '/psn25lons_v3.dat', 'rb') #open region mask longitudes
    maskLats = open(dataPath + '/psn25lats_v3.dat', 'rb') #open region mask latitudes
    shapedLons = np.reshape(np.fromfile(file = maskLons, dtype='<i4')/100000., gridShape) #reshape longitudes to grid shape
    shapedLats = np.reshape(np.fromfile(file = maskLats, dtype='<i4')/100000., gridShape) #reshape latitudes to grid shape

    return shapedMask, shapedLons, shapedLats


relStr='rel004'
runStr='run4'


figPath='../../Figures/'
#figPath='/sea_ice_pso/aapetty/figures/IS2/'+relStr+'/'+runStr+'/Maps/'
if not os.path.exists(figPath):
    os.makedirs(figPath)

IS2_path='/sea_ice_pso/aapetty/thickness_data/'+relStr+'/'+runStr+'/final_data_gridded/002/'
concDataPath='/sea_ice_pso/aapetty/raw_data/ICECONC/CDR/monthly/v4/'
iceTypePath='/sea_ice_pso/aapetty/raw_data/ICETYPE/OSISAF/'
region_mask_data='/sea_ice_pso/aapetty/raw_data/OTHER/'

startYear = 2018
endYear = 2020
winters = getWinterDateRange(startYear, endYear) #get date range for winter 18-19 and winter 19-20

is2 = getIS2Data(IS2_path, winters)

#drop projection variable 
#is2 = is2.drop('projection')

#get lat and lon
is2Lats = is2.latitude.isel(time = 0).values
is2Lons = is2.longitude.isel(time = 0).values
is2LonsAttrs = is2.longitude.attrs 
is2LatsAttrs = is2.latitude.attrs

is2X=is2.xgrid.isel(time = 0).values
is2Y=is2.ygrid.isel(time = 0).values

#assign lat and lon as coordinates to dataset
is2 = is2.assign_coords(coords = {'latitude': (('y','x'), is2Lats), 'longitude': (('y','x'), is2Lons)})


regionMask, maskLons, maskLats = getRegionMask(region_mask_data)

#coords and attributes for Region Mask
regionMaskCoords = {'region_mask': (('y','x'), regionMask)}
regionMaskKeys = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 20, 21])
regionMaskLabels = np.array(['non-region oceans', 'Sea of Okhotsk and Japan','Bering Sea','Hudson Bay','Gulf of St. Lawrence',
                    'Baffin Bay, Davis Strait & Labrador Sea','Greenland Sea', 'Barents Seas','Kara Sea','Laptev Sea','East Siberian Sea',
                    'Chukchi Sea','Beaufort Sea','Canadian Archipelago','Arctic Ocean','Land','Coast'])
regionMaskAttrs = {'description': 'NSIDC region mask for the Arctic', 'keys': regionMaskKeys, 'labels' : regionMaskLabels, 'note': 'keys and labels ordered to match by index'}


#add region mask as coordinate to dataset
is2 = is2.assign_coords(coords = regionMaskCoords)

yearStrs = ['2020', '2021']
monStr='04'
monLabel=cF.monLabels(int(monStr)-1)


strs=[monLabel+' '+yearStrs[0], monLabel+' '+yearStrs[1]]
print(strs)
#var='freeboard'
#var='snow_depth'
var='ice_thickness_int'

if var =='freeboard':
    factor=100
    minValue = 0
    maxValue=80
    minValueDiff=-20
    maxValueDiff=20
    tickint= 5
    varStr='sea ice freeboard'
    units='(cm)'
    cmap = plt.cm.YlOrRd
    labels=['(a) '+ strs[0], '(b) '+strs[1], '(c) '+strs[1][4:]+' - '+strs[0][4:]]


elif var =='snow_depth':
    factor=100
    minValue = 0
    maxValue=60
    minValueDiff=-20
    maxValueDiff=20
    tickint= 5
    varStr='snow depth'
    units='(cm)'
    labels=['(d) ', '(e) ', '(f)']
    cmap = plt.cm.BuPu


elif var =='ice_thickness':
    factor=1.
    minValue = 0
    maxValue=5
    minValueDiff=-1.25
    maxValueDiff=1.25
    tickint= 6
    varStr='sea ice thickness'
    units='(m)'
    labels=['(g) ', '(h) ', '(i)']
    labels=['(a) '+ strs[0], '(b) '+strs[1], '(c) '+strs[1][4:]+' - '+strs[0][4:]]
    cmap=cmocean.cm.thermal

elif var =='ice_thickness_int':
    factor=1.
    minValue = 0
    maxValue=5
    minValueDiff=-1.25
    maxValueDiff=1.25
    tickint= 6
    varStr='sea ice thickness'
    units='(m)'
    labels=['(g) ', '(h) ', '(i)']
    labels=['(a) '+ strs[0], '(b) '+strs[1], '(c) '+strs[1][4:]+' - '+strs[0][4:]]
    cmap=cmocean.cm.thermal

#data=[is2[var].sel(time = str1).values[0]*factor, is2[var].sel(time = str2).values[0]*factor, is2[var].sel(time = str2).values[0]*factor - is2[var].sel(time = str1).values[0]*factor]

minval=[minValue, minValue, minValueDiff]
maxval=[maxValue, maxValue, maxValueDiff]

smoothing=False

data=np.empty((3,448, 304))
data[:] = np.nan

iceconcs=np.empty((2,448, 304))
iceconcs[:] = np.nan

for i in range(len(yearStrs)):
    iceconcs[i]=cF.get_cdr_conc_v2(concDataPath, yearStrs[i], monStr)

if smoothing:
    kernel = Gaussian2DKernel(x_stddev=0.5)
    for i in range(len(yearStrs)):
        varG_ma=is2[var].sel(time = strs[i]).values[0]*factor
        varG_ma[np.where(iceconcs[i]<0.5)]=np.nan
        varG_ma_int = convolve(varG_ma, kernel)
        varG_ma_int[np.where(iceconcs[i]<0.5)]=np.nan
        varG_ma_int[np.where(is2Lats>88)]=np.nan
        data[i] = varG_ma_int

    data[2] = data[1] - data[0]
else:
    data[0] = is2[var].sel(time = strs[0]).values[0]*factor
    data[1] = is2[var].sel(time = strs[1]).values[0]*factor
    data[2] = data[1] - data[0]


regions = [8, 9, 10, 11, 12, 13, 15] #Inner Arctic

regionMask_mask = np.isin(regionMask, regions).astype(int)

# do masked-array on the lon_2d
lon2d_greater = ma.masked_greater(is2Lons, -0.01)
lon2d_lesser = ma.masked_less(is2Lons, 0)

# apply masks to other associate arrays: lat_2d
lat2d_greater = ma.MaskedArray(is2Lats, mask=lon2d_greater.mask)
lat2d_lesser = ma.MaskedArray(is2Lats, mask=lon2d_lesser.mask)
# apply masks to other associate arrays: snow_2d
regionMask_mask_g = ma.MaskedArray(regionMask_mask, mask=lon2d_greater.mask)
regionMask_mask_l = ma.MaskedArray(regionMask_mask, mask=lon2d_lesser.mask)



cbarlabels=[varStr+' '+units, varStr+' '+units, varStr+' difference '+units]
cmaps=[cmap,  cmap, plt.cm.RdBu_r]

fig, axs = plt.subplots(1, 3, figsize=(8, 4.3), subplot_kw=dict(projection=ccrs.NorthPolarStereo(central_longitude=-45)))
plt.subplots_adjust(bottom=0.01, wspace=0.03, left=0.02, top=0.94, right=0.98)


for i in range(len(data)):
    ax=axs.flatten()[i]
    plt.sca(ax)
    
    im1 = ax.pcolormesh(is2Lons , is2Lats, data[i], cmap=cmaps[i], vmin=minval[i], vmax=maxval[i], transform=ccrs.PlateCarree(), edgecolors='None', zorder=2, rasterized=True)
    if i<2:
        im11=ax.pcolormesh(is2Lons, is2Lats, iceconcs[i], vmin=0, vmax=2, cmap=plt.cm.gray_r, transform=ccrs.PlateCarree(), zorder=1)
    if i<3:
        im12 = ax.contour(lon2d_greater , lat2d_greater, regionMask_mask_g, color='c', linewidth=2, levels=[0.5],transform=ccrs.PlateCarree(), zorder=3)
        im121 = ax.contour(lon2d_lesser , lat2d_lesser, regionMask_mask_l, color='c', linewidth=2, levels=[0.5],transform=ccrs.PlateCarree(), zorder=3)
    
    ax.coastlines(resolution='50m', linewidth=0.22, zorder=3)
    ax.gridlines(draw_labels=False,
              linewidth=0.22, color='gray', alpha=0.5, linestyle='--',zorder=4)
    ax.add_feature(cfeature.LAND, facecolor='0.95', zorder=2)

    ax.set_extent([-179, 179, 48, 90], ccrs.PlateCarree())
    ax.set_xlim([np.percentile(is2X, 3), np.percentile(is2X, 97)])

    cax,kw = mcbar.make_axes(ax,location='bottom',pad=0.01,shrink=0.8)
    cb=fig.colorbar(im1,cax=cax,extend='both',**kw)
    #cb.set_label(varStr+' ('+units_lab+')',size=8)
    #ax.set_title(varStr+' '+date_string+month_string+extra)
    cb.set_ticks(np.linspace(minval[i], maxval[i], tickint) )
    cb.set_label(cbarlabels[i], labelpad=3)
    #im1=hexbin(xpts_sections, ypts_sections, C=data[i], vmin=minval[i], vmax=maxval[i], gridsize=gridbins, cmap=cmaps[i], zorder=2, rasterized=True)
    
    ax.annotate(labels[i], xy=(0.02, 1.01), xycoords='axes fraction', verticalalignment='bottom', horizontalalignment='left',color='k')

#plt.tight_layout()
fig.savefig(figPath+'/comp_maps'+var+strs[0][0:3]+'-'+strs[0][0:3]+'c.png', dpi=300)

